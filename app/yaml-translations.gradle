buildscript {
    repositories {
        mavenCentral()  // Afegeix aquesta línia
    }
    dependencies {
        classpath 'com.fasterxml.jackson.core:jackson-databind:2.15.2'
        classpath 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.15.2'
    }
}

// Custom task to convert YAML to Android strings
task yamlToAndroidStrings {
    doLast {
        def yamlDir = file('src/main/translations/')
        def resDir = file('src/main/res/')
        def defaultLanguage = 'en'

        if (!yamlDir.exists()) {
            println "Translations directory not found: ${yamlDir.absolutePath}"
            return
        }

        // Cerca tots els idiomes disponibles
        def languageCodes = []
        yamlDir.eachFileMatch(groovy.io.FileType.FILES, ~/.*\.(yml|yaml)/) { yamlFile ->
            def langCode = yamlFile.name - '.yml' - '.yaml'  // Elimina l'extensió
            langCode = langCode.toLowerCase()
            languageCodes.add(langCode)
        }

        // Genera el fitxer arrays_languages.xml
        def arraysFile = new File(resDir, 'values/arrays_languages.xml')
        def xmlContent = """<?xml version="1.0" encoding="utf-8"?>
<!-- AUTO-GENERATED FILE. DO NOT EDIT MANUALLY. -->
<!-- This file is generated automatically from YAML translations. -->
<!-- Any manual changes will be overwritten. -->
<resources>
    <string-array name="supported_language_codes">
${languageCodes.collect { "        <item>$it</item>" }.join('\n')}
    </string-array>
</resources>"""

        arraysFile.write(xmlContent)
        println "Generated language arrays: ${languageCodes.join(', ')}"

        // Processa els fitxers YAML existents
        yamlDir.eachFileMatch(groovy.io.FileType.FILES, ~/.*\.(yml|yaml)/) { yamlFile ->
            def langCode = yamlFile.name - '.yml' - '.yaml'  // Elimina l'extensió
            langCode = langCode.toLowerCase()

            def qualifier = (langCode == defaultLanguage || langCode == 'default') ? 'values' : "values-${langCode}"
            def targetDir = new File(resDir, qualifier)
            targetDir.mkdirs()

            def xmlFile = new File(targetDir, 'strings.xml')
            convertYamlToAndroidXml(yamlFile, xmlFile)
            println "Generated: ${xmlFile.absolutePath}"
        }
    }
}

// Android-specific string escaping
def escapeAndroidString(input) {
    def escaped = input
        .replace("\\", "\\\\")  // Backslash
        .replace("'", "\\'")    // Single quote
        .replace("\"", "\\\"")  // Double quote
        .replace("\n", "\\n")   // Newline
        .replace("\t", "\\t")   // Tab
        .replace("\r", "\\r")   // Carriage return
    if (escaped.startsWith("??")) {
        escaped = "\\?" + escaped.substring(1)  // Escapa el primer ?
    } else if (escaped.contains("??")) {
        escaped = escaped.replace("??", "\\?\\?")  // Escapa tots els ??
    }

    return escaped
}

// Helper method for YAML to XML conversion
def convertYamlToAndroidXml(yamlFile, xmlFile) {
    def mapper = new com.fasterxml.jackson.databind.ObjectMapper(
        new com.fasterxml.jackson.dataformat.yaml.YAMLFactory()
    )

    def yamlContent = mapper.readValue(yamlFile.text, Map)

    // Create XML using DOM
    def factory = javax.xml.parsers.DocumentBuilderFactory.newInstance()
    factory.setNamespaceAware(true)
    def builder = factory.newDocumentBuilder()
    def doc = builder.newDocument()

    // Add comment header
    def commentText = " AUTO-GENERATED from ${yamlFile.name}. DO NOT EDIT THIS FILE DIRECTLY! "
    def comment = doc.createComment(commentText)
    doc.appendChild(comment)

    def resourcesElement = doc.createElement('resources')
    doc.appendChild(resourcesElement)

    // Process the YAML content recursively
    processYamlMap(yamlContent, '', resourcesElement)

    // Write XML with formatting
    def transformerFactory = javax.xml.transform.TransformerFactory.newInstance()
    def transformer = transformerFactory.newTransformer()
    transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, 'yes')
    transformer.setOutputProperty('{http://xml.apache.org/xslt}indent-amount', '4')
    transformer.setOutputProperty(javax.xml.transform.OutputKeys.ENCODING, 'utf-8')
    transformer.setOutputProperty(javax.xml.transform.OutputKeys.STANDALONE, 'yes')

    def result = new javax.xml.transform.stream.StreamResult(xmlFile)
    def source = new javax.xml.transform.dom.DOMSource(doc)
    transformer.transform(source, result)
}

// Separate method to avoid Groovy closure recursion issues
def processYamlMap(map, prefix, resourcesElement) {
    map.each { key, value ->
        def fullKey = prefix.isEmpty() ? key.toString() : "${prefix}__${key}"
        if (value instanceof Map) {
            processYamlMap(value, fullKey, resourcesElement)
        } else if (value instanceof String) {
            def finalKey = fullKey.toLowerCase()
            def stringElement = resourcesElement.ownerDocument.createElement('string')
            stringElement.setAttribute('name', finalKey)
            def escapedValue = escapeAndroidString(value)
            stringElement.setTextContent(escapedValue)
            resourcesElement.appendChild(stringElement)
        }
    }
}

// Run the conversion before build
preBuild.dependsOn yamlToAndroidStrings
